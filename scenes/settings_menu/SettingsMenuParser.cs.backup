using Godot;
using Project.Settings;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
namespace Project.SettingsMenuParser; 

// TODO: This file should be reformatted. Code is very messy

// TODO: I should implement a way to specify default values, so controls like LineEdit show the default value when no value is entered.

#region Defining the settings elements
// TODO: I should maybe make the `Connect`s return a reference to the current object instead of the value
public delegate void ParamFunc<in T>(T value);
public interface IElement {
	public Control GetNode();
}
public abstract class BaseElement<TValue, TNode> : IElement where TNode: Control {
	public TValue Value;
	public TNode Node;
	public Control GetNode() => Node;
	public abstract void Connect(ParamFunc<TValue> callable);
}
public class SliderElement : BaseElement<float, HSlider> {
	public float Min, Max=10f, Step=0.5f;
	public SliderElement() {
		var node = new HSlider();
		node.MinValue = Min;
		node.MaxValue = Max;
		node.Step = Step;
		node.Value = Value;
		Node = node;
	}
	public override void Connect(ParamFunc<float> callable) {
		Node.ValueChanged += (val) => {
			Value = (float) val;
			callable.Invoke(Value);
		};
	}
}
public class CheckboxElement : BaseElement<bool, CheckBox> {
	public CheckboxElement() {
		var node = new CheckBox();
		node.ButtonPressed = Value;
		Node = node;
	}
	public override void Connect(ParamFunc<bool> callable) {
		Node.Pressed += () => {
			Value = Node.ButtonPressed;
			callable.Invoke(Value);
		};
	}
}

public class TextBoxElement : BaseElement<string, LineEdit> {
	public TextBoxElement() {
		var node = new LineEdit();
		node.Text = Value;
		Node = node;
	}
	public override void Connect(ParamFunc<string> callable)  {
		Node.TextChanged += (str) => {
			Value = str;
			callable.Invoke(Value);
		};
	}
}

public class TwoNumElement : BaseElement<Vector2, HBoxContainer> {
	public List<LineEdit> TextBoxes = new();
	public TwoNumElement() {
		var parent = new HBoxContainer();
		foreach (var value in new[] { Value.X, Value.Y }) {
			var node = new LineEdit();
			node.Text = $"{value}";
			parent.AddChild(node);
			TextBoxes.Add(node);
		}
		Node = parent;
	}
	public override void Connect(ParamFunc<Vector2> callable)  {
		// TODO: Add safety check for the parses
		float ParseX(string text) {
			if (!float.TryParse(text, out var output))
				output = Value.X;
			return output;
		}
		float ParseY(string text) {
			if (!float.TryParse(text, out var output))
				output = Value.Y;
			return output;
		}
		
		// Connecting to X and Y value stuff
		TextBoxes[0].TextChanged += (newVal) => {
			var x = ParseX(newVal);
			Value.X = x;
			callable.Invoke(new Vector2(x, Value.Y));
		};
		TextBoxes[1].TextChanged += (newVal) => {
			var y = ParseY(newVal);
			Value.Y = y;
			callable.Invoke(new Vector2(Value.X, y));
		};
	}
}
#endregion

// Main parser
public static class Parser {
	/// Can return null. Return value should be casted to some form of BaseElement
	public static IElement ParseFieldAttributes(FieldInfo sectionField, FieldInfo field) {
		if (sectionField.ReflectedType is null) return null;
		
		// Getting the core attrib
		var settingsData = sectionField.GetValue(EngineSettings.Get);
		var element = field.GetValue(settingsData) switch {
			float num => new SliderElement { Value = num },
			int num => new SliderElement { Value = num },

			bool ticked => new CheckboxElement { Value = ticked },
			string text => new TextBoxElement { Value = text },

			Vector2 vector => new TwoNumElement { Value = vector },
			Vector2I vector => new TwoNumElement { Value = vector },

			{ } other => ((Func<IElement>)(() => {
				OS.Alert($"Settings menu UI element \"{other.GetType()}\" is not implemented!", "Not implemented!");
				return null;
			}))()
		};
		
		// Parsing the attributes (min/max slider boundaries, etc)
		var attributes = field.CustomAttributes;
		foreach (var attrib in attributes) {
			bool hasPropertyHint = false;
			foreach (var arg in attrib.ConstructorArguments) {
				if (arg.ArgumentType.Name == "PropertyHint") {
					hasPropertyHint = true;
					continue;
				}
				
				// Some safety checks
				if (arg.Value is null || arg.Value.ToString() is null)
					continue;

				// Using the next argument as the hint
				if (hasPropertyHint) {
					var list = arg.Value.ToString()!.Split(",").ToList();
					float[] split = (from x in list select float.Parse(x.Trim())).ToArray();

					var (min, max, step) = (split[0], split[1], split[2]);
					if (element is SliderElement sliderElement) {
						sliderElement.Min = min;
						sliderElement.Max = max;
						sliderElement.Step = step;
					}
					GD.Print($"min={min} max={max} step={step}");
				}
			}
		}

		return element;
	}
}
